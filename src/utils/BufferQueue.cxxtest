/** \copyright
 * Copyright (c) 2013, Stuart W Baker
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are  permitted provided that the following conditions are met:
 * 
 *  - Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  - Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * \file BufferQueue.cxxtest
 * This file contains a unit test for classes in BufferQueue.hxx and
 * BufferQueue.cxx.
 *
 * @author Stuart W. Baker
 * @date 14 September 2013
 */

#include "gtest/gtest.h"
#include "utils/BufferQueue.hxx"
#include "executor/StateFlow.hxx"

#if 0
TEST(BufferTest, free_alloc_init_4)
{
    Buffer *buffer = mainBufferPool->buffer_alloc(4);
    EXPECT_TRUE(buffer != NULL);
    buffer->free();
    buffer = mainBufferPool->buffer_alloc(4);
    EXPECT_TRUE(buffer != NULL);    
}

TEST(BufferTest, free_alloc_init_8)
{
    Buffer *buffer = mainBufferPool->buffer_alloc(8);
    EXPECT_TRUE(buffer != NULL);
    buffer->free();
    buffer = mainBufferPool->buffer_alloc(8);
    EXPECT_TRUE(buffer != NULL);    
}

TEST(BufferTest, free_alloc_init_16)
{
    Buffer *buffer = mainBufferPool->buffer_alloc(16);
    EXPECT_TRUE(buffer != NULL);
    buffer->free();
    buffer = mainBufferPool->buffer_alloc(16);
    EXPECT_TRUE(buffer != NULL);    
}

TEST(BufferTest, free_alloc_init_32)
{
    Buffer *buffer = mainBufferPool->buffer_alloc(32);
    EXPECT_TRUE(buffer != NULL);
    buffer->free();
    buffer = mainBufferPool->buffer_alloc(32);
    EXPECT_TRUE(buffer != NULL);    
}

TEST(BufferTest, advance_size_available)
{
    Buffer *buffer = mainBufferPool->buffer_alloc(100);
    buffer->advance(10);
    EXPECT_TRUE(buffer->size() == 100);
    EXPECT_TRUE(buffer->available() == 90);
    EXPECT_TRUE((char*)buffer->start() + 10 == buffer->position());
}

TEST(BufferTest, expand)
{
    Buffer *buffer = mainBufferPool->buffer_alloc(100);
    buffer = buffer->expand(200);
    EXPECT_TRUE(buffer->size() == 200);
    EXPECT_TRUE(buffer->available() == 200);
    EXPECT_TRUE(buffer->start() == buffer->position());
}

TEST(BufferQueueTest, all)
{
    Buffer *buffer1 = mainBufferPool->buffer_alloc(100);
    Buffer *buffer2 = mainBufferPool->buffer_alloc(32);
    EXPECT_TRUE(buffer1 != NULL);
    EXPECT_TRUE(buffer2 != NULL);
    BufferQueue *queue = new BufferQueue();
    EXPECT_TRUE(queue != NULL);
    EXPECT_EQ(queue->pending(), (size_t)0);
    EXPECT_TRUE(queue->empty());
    EXPECT_TRUE(queue->next() == NULL);

    queue->insert(buffer1);
    EXPECT_EQ(queue->pending(), (size_t)1);
    EXPECT_FALSE(queue->empty());

    queue->insert(buffer2);
    EXPECT_EQ(queue->pending(), (size_t)2);
    EXPECT_FALSE(queue->empty());

    EXPECT_TRUE(queue->next() == buffer1);
    EXPECT_EQ(queue->pending(), (size_t)1);
    EXPECT_FALSE(queue->empty());

    EXPECT_TRUE(queue->next() == buffer2);
    EXPECT_EQ(queue->pending(), (size_t)0);
    EXPECT_TRUE(queue->empty());

    EXPECT_TRUE(queue->next() == NULL);
    
    queue->buffer_free(buffer1);
    queue->buffer_free(buffer2);
}

TEST(BufferQueueWaitTest, all)
{
    long long start, stop;

    Buffer *buffer1 = mainBufferPool->buffer_alloc(100);
    Buffer *buffer2 = mainBufferPool->buffer_alloc(32);
    Buffer *buffer3 = mainBufferPool->buffer_alloc(8);
    EXPECT_TRUE(buffer1 != NULL);
    EXPECT_TRUE(buffer2 != NULL);
    EXPECT_TRUE(buffer3 != NULL);
    BufferQueueWait *queue = new BufferQueueWait();
    EXPECT_TRUE(queue != NULL);
    EXPECT_EQ(queue->pending(), (size_t)0);
    EXPECT_TRUE(queue->empty());
    EXPECT_TRUE(queue->next() == NULL);

    queue->insert(buffer1);
    EXPECT_EQ(queue->pending(), (size_t)1);
    EXPECT_FALSE(queue->empty());

    queue->insert(buffer2);
    EXPECT_EQ(queue->pending(), (size_t)2);
    EXPECT_FALSE(queue->empty());

    queue->insert(buffer3);
    EXPECT_EQ(queue->pending(), (size_t)3);
    EXPECT_FALSE(queue->empty());

    EXPECT_TRUE(queue->next() == buffer1);
    EXPECT_EQ(queue->pending(), (size_t)2);
    EXPECT_FALSE(queue->empty());

    EXPECT_TRUE(queue->wait() == buffer2);
    EXPECT_EQ(queue->pending(), (size_t)1);
    EXPECT_FALSE(queue->empty());

    start = OSTime::get_monotonic();
    EXPECT_TRUE(queue->timedwait(OS_WAIT_FOREVER) == buffer3);
    EXPECT_EQ(queue->pending(), (size_t)0);
    EXPECT_TRUE(queue->empty());
    stop = OSTime::get_monotonic();
    EXPECT_TRUE((stop - start) < (long long)1000000);

    start = OSTime::get_monotonic();
    EXPECT_TRUE(queue->next() == NULL);
    EXPECT_TRUE(queue->timedwait(1000000000) == NULL);
    stop = OSTime::get_monotonic();
    EXPECT_TRUE((stop - start) > (long long)998000000);
    EXPECT_TRUE((stop - start) < (long long)1002000000);
    
    queue->buffer_free(buffer1);
    queue->buffer_free(buffer2);
    queue->buffer_free(buffer3);
}

#endif

TEST(BufferBase, alloc)
{
    struct Item
    {
        uint32_t param1;
        uint16_t param2;
        uint16_t param3;
    };
    
    Buffer<Item> *buffer;
    mainBufferPool->alloc<Item>(&buffer);
    EXPECT_TRUE(buffer->references() == 1);
    
    buffer->data()->param1 = 4;
    buffer->data()->param2 = 5;
    buffer->data()->param3 = 6;
    
    EXPECT_TRUE(buffer->ref() == buffer);
    EXPECT_TRUE(buffer->references() == 2);
    
    buffer->unref();
    EXPECT_TRUE(buffer->references() == 1);
    buffer->unref();
}

Executor<1> executor("executor", 0, 1024);

TEST(BufferBase, alloc_async)
{
    struct Item
    {
        uint32_t param1;
        uint16_t param2;
        uint16_t param3;
    };
    
    class TrivialFlow : public StateFlowBase
    {
    public:
        TrivialFlow(Service *s)
            : StateFlowBase(s)
        {}
    };
    
    Service service(&executor);
    TrivialFlow flow(&service);
    
    mainBufferPool->alloc_async<Item>(&flow);
}

DynamicPool *unalignedBufferPool = new DynamicPool(Bucket::init(5, 9, 0));

TEST(BufferBase, alloc_unaligned)
{
    struct Item
    {
        uint32_t param1;
        uint16_t param2;
        uint16_t param3;
    };
    
    Buffer<Item> *buffer;
    unalignedBufferPool->alloc<Item>(&buffer);
    EXPECT_TRUE(buffer->references() == 1);
    buffer->unref();
}

TEST(QList, all)
{
    struct Item : public QMember
    {
    };
    
    QList<3> q;
    Item a;
    Item b;
    Item c;
    Item d;
    
    q.insert(&a, 2);
    q.insert(&b, 1);
    q.insert(&c, 0);
    q.insert(&d, 0);
    
    EXPECT_TRUE(q.next(2) == &a);
    EXPECT_TRUE(q.next(1) == &b);
    EXPECT_TRUE(q.next(0) == &c);
    EXPECT_TRUE(q.next(0) == &d);

    q.insert(&a, 2);
    q.insert(&b, 1);
    q.insert(&c, 0);
    q.insert(&d, 0);
    
    EXPECT_TRUE(q.pending() == 4);
    EXPECT_TRUE(q.pending(2) == 1);
    EXPECT_TRUE(q.pending(1) == 1);
    EXPECT_TRUE(q.pending(0) == 2);
    EXPECT_FALSE(q.empty());
    EXPECT_FALSE(q.empty(2));
    EXPECT_FALSE(q.empty(1));
    EXPECT_FALSE(q.empty(0));
    
    QList<3>::Result result;
    result = q.next();
    EXPECT_TRUE(result.item == &c);
    EXPECT_TRUE(result.index == 0);
    result = q.next();
    EXPECT_TRUE(result.item == &d);
    EXPECT_TRUE(result.index == 0);
    result = q.next();
    EXPECT_TRUE(result.item == &b);
    EXPECT_TRUE(result.index == 1);
    result = q.next();
    EXPECT_TRUE(result.item == &a);
    EXPECT_TRUE(result.index == 2);

    EXPECT_TRUE(q.empty());
    EXPECT_TRUE(q.empty(2));
    EXPECT_TRUE(q.empty(1));
    EXPECT_TRUE(q.empty(0));

    result = q.next();
    EXPECT_TRUE(result.item == NULL);
}

TEST(QListProtected, all)
{
    struct Item : public QMember
    {
    };
    
    QListProtected<3> q;
    Item a;
    Item b;
    Item c;
    Item d;
    
    q.insert(&a, 2);
    q.insert(&b, 1);
    q.insert(&c, 0);
    q.insert(&d, 0);
    
    EXPECT_TRUE(q.next(2) == &a);
    EXPECT_TRUE(q.next(1) == &b);
    EXPECT_TRUE(q.next(0) == &c);
    EXPECT_TRUE(q.next(0) == &d);

    q.insert(&a, 2);
    q.insert(&b, 1);
    q.insert(&c, 0);
    q.insert(&d, 0);
    
    EXPECT_TRUE(q.pending() == 4);
    EXPECT_TRUE(q.pending(2) == 1);
    EXPECT_TRUE(q.pending(1) == 1);
    EXPECT_TRUE(q.pending(0) == 2);
    EXPECT_FALSE(q.empty());
    EXPECT_FALSE(q.empty(2));
    EXPECT_FALSE(q.empty(1));
    EXPECT_FALSE(q.empty(0));
    
    QList<3>::Result result;
    result = q.next();
    EXPECT_TRUE(result.item == &c);
    EXPECT_TRUE(result.index == 0);
    result = q.next();
    EXPECT_TRUE(result.item == &d);
    EXPECT_TRUE(result.index == 0);
    result = q.next();
    EXPECT_TRUE(result.item == &b);
    EXPECT_TRUE(result.index == 1);
    result = q.next();
    EXPECT_TRUE(result.item == &a);
    EXPECT_TRUE(result.index == 2);

    EXPECT_TRUE(q.empty());
    EXPECT_TRUE(q.empty(2));
    EXPECT_TRUE(q.empty(1));
    EXPECT_TRUE(q.empty(0));

    result = q.next();
    EXPECT_TRUE(result.item == NULL);
}

struct Item : public QMember
{
};

Item global;

void *QListProtectedWait_thread(void *arg)
{
    QListProtectedWait<3>* q = static_cast<QListProtectedWait<3>*>(arg);
    
    q->insert(&global, 0);
    return NULL;
}

void *QListProtectedWait_signal_thread(void *arg)
{
    QListProtectedWait<3>* q = static_cast<QListProtectedWait<3>*>(arg);
    
    q->wakeup();
    return NULL;
}

void *QListProtectedWait_thread_timed(void *arg)
{
    QListProtectedWait<3>* q = static_cast<QListProtectedWait<3>*>(arg);
    
    q->insert(&global, 0);
    return NULL;
}

void *QListProtectedWait_signal_thread_timed(void *arg)
{
    QListProtectedWait<3>* q = static_cast<QListProtectedWait<3>*>(arg);
    
    q->wakeup();
    return NULL;
}

TEST(QListProtectedWait, all)
{
    QListProtectedWait<3> q;
    Item a;
    Item b;
    Item c;
    Item d;

    q.insert(&a, 2);
    q.insert(&b, 1);
    q.insert(&c, 0);
    q.insert(&d, 0);
    
    EXPECT_TRUE(q.pending() == 4);
    EXPECT_TRUE(q.pending(2) == 1);
    EXPECT_TRUE(q.pending(1) == 1);
    EXPECT_TRUE(q.pending(0) == 2);
    EXPECT_FALSE(q.empty());
    EXPECT_FALSE(q.empty(2));
    EXPECT_FALSE(q.empty(1));
    EXPECT_FALSE(q.empty(0));
    
    QList<3>::Result result;
    result = q.next();
    EXPECT_TRUE(result.item == &c);
    EXPECT_TRUE(result.index == 0);
    result = q.next();
    EXPECT_TRUE(result.item == &d);
    EXPECT_TRUE(result.index == 0);
    result = q.next();
    EXPECT_TRUE(result.item == &b);
    EXPECT_TRUE(result.index == 1);
    result = q.next();
    EXPECT_TRUE(result.item == &a);
    EXPECT_TRUE(result.index == 2);

    EXPECT_TRUE(q.empty());
    EXPECT_TRUE(q.empty(2));
    EXPECT_TRUE(q.empty(1));
    EXPECT_TRUE(q.empty(0));

    result = q.next();
    EXPECT_TRUE(result.item == NULL);
    
    pthread_t thread;
    pthread_create(&thread, NULL, QListProtectedWait_thread, &q);
    result = q.wait();
    EXPECT_TRUE(result.item == &global);
    EXPECT_TRUE(result.index == 0);

    pthread_create(&thread, NULL, QListProtectedWait_signal_thread, &q);
    result = q.wait();
    EXPECT_TRUE(result.item == NULL);
    EXPECT_TRUE(errno == EINTR);

    pthread_create(&thread, NULL, QListProtectedWait_thread_timed, &q);
    result = q.timedwait(500000000);
    EXPECT_TRUE(result.item == &global);
    EXPECT_TRUE(result.index == 0);

    pthread_create(&thread, NULL, QListProtectedWait_signal_thread_timed, &q);
    result = q.timedwait(500000000);
    EXPECT_TRUE(result.item == NULL);
    EXPECT_TRUE(errno == EINTR);

    result = q.timedwait(500000000);
    EXPECT_TRUE(result.item == NULL);
    EXPECT_TRUE(errno == ETIMEDOUT);
}

int appl_main(int argc, char* argv[])
{
    testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

