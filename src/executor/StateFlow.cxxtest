#include "utils/test_main.hxx"

#include <stdint.h>
#include <list>

#include "executor/StateFlow.hxx"

class StateFlowTest : public testing::Test
{
public:
    StateFlowTest()
    {
    }
    ~StateFlowTest()
    {
        wait();
    }

protected:
    SyncNotifiable done_notifier_;

    void wait()
    {
        wait_for_main_executor();
    }
};

class TrivialFlow : public StateFlowBase
{
public:
    TrivialFlow(Service *s)
        : StateFlowBase(s)
    {
    }
};

TEST_F(StateFlowTest, CreateDestroyBase)
{
    TrivialFlow f(&g_service);
}

class SimpleTestFlow : public StateFlowBase
{
public:
    SimpleTestFlow()
        : StateFlowBase(&g_service)
    {
    }

    void DoSomethingSimple(int foo, int *bar)
    {
        foo_ = foo;
        bar_ = bar;
        start_flow(STATE(CopyData));
    }

private:
    Action CopyData()
    {
        *bar_ = foo_;
        return exit();
    }

    int foo_;
    int *bar_;
};

TEST_F(StateFlowTest, NotifyEmptyFlow)
{
    TrivialFlow f(&g_service);
    f.notify();
    wait();
}

TEST_F(StateFlowTest, SimpleFlow)
{
    int a = 5, b = 0;
    SimpleTestFlow f;
    f.DoSomethingSimple(a, &b);
    wait();
    EXPECT_EQ(5, b);
}

struct Id
{
    typedef uint32_t id_type;
    uint32_t id_;
    id_type id()
    {
        return id_;
    }
};

class QueueTestFlow : public StateFlow<Buffer<Id>, QList<3>>
{
public:
    QueueTestFlow(vector<uint32_t> *seen_ids)
        : StateFlow(&g_service)
        , seenIds_(seen_ids)
    {
    }

protected:
    virtual Action entry()
    {
        seenIds_->push_back(message()->data()->id_);
        return release_and_exit();
    }

private:
    vector<uint32_t> *seenIds_;
};

DynamicPool g_message_pool(Bucket::init(4, 8, 16, 32, 0));

class QueueTest : public StateFlowTest
{
public:
    QueueTest()
        : flow_(&seenIds_)
    {
    }

protected:
    vector<uint32_t> seenIds_;
    QueueTestFlow flow_;
};

TEST_F(QueueTest, Nothing)
{
    wait();
    EXPECT_TRUE(seenIds_.empty());
}

TEST_F(QueueTest, OneItem)
{
    Buffer<Id> *first;
    g_message_pool.alloc(&first);
    first->data()->id_ = 42;
    wait();
    EXPECT_TRUE(seenIds_.empty());
    flow_.send(first);
    wait();
    ASSERT_EQ(1U, seenIds_.size());
    EXPECT_EQ(42U, seenIds_[0]);
}

TEST_F(QueueTest, ThreeItems)
{
    Buffer<Id> *first;
    g_message_pool.alloc(&first);
    first->data()->id_ = 42;
    EXPECT_TRUE(seenIds_.empty());

    flow_.send(first);
    wait();
    ASSERT_EQ(1U, seenIds_.size());
    EXPECT_EQ(42U, seenIds_[0]);

    Buffer<Id> *second;
    g_message_pool.alloc(&second);
    second->data()->id_ = 43;
    flow_.send(second);

    Buffer<Id> *third;
    g_message_pool.alloc(&third);
    third->data()->id_ = 44;
    flow_.send(third);
    wait();
    ASSERT_EQ(3U, seenIds_.size());
    EXPECT_EQ(42U, seenIds_[0]);
    EXPECT_EQ(43U, seenIds_[1]);
    EXPECT_EQ(44U, seenIds_[2]);
}

/// @Todo(balazs.racz): figure out why this does not work.
TEST_F(QueueTest, DISABLED_Priorities)
{
    Buffer<Id> *m[3];
    g_message_pool.alloc(m + 0);
    g_message_pool.alloc(m + 1);
    g_message_pool.alloc(m + 2);
    m[0]->data()->id_ = 42;
    m[1]->data()->id_ = 43;
    m[2]->data()->id_ = 44;
    // We block the executor before sending off the messages to avoid this test
    // being flakey on multi-core processors.
    BlockExecutor b;
    g_executor.add(&b, 0);
    b.wait_for_blocked();

    flow_.send(m[0]);
    flow_.send(m[1], 1);
    flow_.send(m[2], 0);
    b.release_block();

    wait();
    // The order of the arrived messages should be reversed.
    ASSERT_EQ(3U, seenIds_.size());
    EXPECT_EQ(44U, seenIds_[0]);
    EXPECT_EQ(43U, seenIds_[1]);
    EXPECT_EQ(42U, seenIds_[2]);
}

/*TEST_F(StateFlowTest, CallDone) {
  SimpleTestFlow f(&done_notifier_);
  int a = 5, b = 0;
  f.DoSomethingSimple(a, &b);
  done_notifier_.WaitForNotification();
  EXPECT_EQ(5, b);
  EXPECT_TRUE(f.IsDone());
  }*/

/*
class SleeperFlow : public StateFlow {
public:
  explicit SleeperFlow(Notifiable* done)
    : StateFlow(&global_executor, done), r_(NULL) {}

  void SleepOnce(bool* r) {
    r_ = r;
    StartFlowAt((MemberFunction)&SleeperFlow::MSleepOnce);
  }

  void SleepNTimes(int n) {
    count_ = n;
    StartFlowAt((MemberFunction)&SleeperFlow::MSleepCount);
  }

  void ReptSleepNTimes(int n) {
    count_ = n;
    WakeUpRepeatedly(&sleep_data_, MSEC_TO_NSEC(3));
    StartFlowAt(STATE(StartReptSleep));
  }

private:
  bool* r_;
  StateFlowAction MSleepOnce() {
    return Sleep(&sleep_data_, MSEC_TO_NSEC(3),
                 (MemberFunction)&SleeperFlow::MSleepDone);
  }

  StateFlowAction MSleepCount() {
    if (count_--) {
      return Sleep(&sleep_data_, MSEC_TO_NSEC(3),
                   (MemberFunction)&SleeperFlow::MSleepCount);
    } else {
      return call_immediately((MemberFunction)&SleeperFlow::MSleepDone);
    }
  }

  StateFlowAction StartReptSleep() {
    return WaitForTimerWakeUpAndCall(
        &sleep_data_,
        (MemberFunction)&SleeperFlow::MReptSleepCount);
  }

  StateFlowAction MReptSleepCount() {
    if (!--count_) {
      StopTimer(&sleep_data_);
      return call_immediately(STATE(MSleepDone));
    }
    return WaitForNotification();
  }

  StateFlowAction MSleepDone() {
    if (r_) *r_ = true;
    return Exit();
  }

  int count_;
  SleepData sleep_data_;
};

TEST_F(StateFlowTest, SleepOnceTest) {
  SleeperFlow f(&done_notifier_);
  bool r = false;
  f.SleepOnce(&r);
  done_notifier_.WaitForNotification();
  EXPECT_TRUE(r);
  EXPECT_TRUE(f.IsDone());
}

TEST_F(StateFlowTest, SleepNTest) {
  SleeperFlow f(&done_notifier_);
  f.SleepNTimes(3);
  done_notifier_.WaitForNotification();
}

TEST_F(StateFlowTest, SleepReptTest) {
  SleeperFlow f(&done_notifier_);
  f.ReptSleepNTimes(3);
  done_notifier_.WaitForNotification();
}


class SubFlowCaller : public StateFlow {
public:
  explicit SubFlowCaller(Notifiable* done)
    : StateFlow(&global_executor, done) {}

  void RunFlowAndSubFlow(bool *r) {
    r_ = r;
    StartFlowAt(STATE(Start));
  }

private:
  bool* r_;
  SleeperFlow* sleeper_flow_;

  StateFlowAction Start() {
    sleeper_flow_ = new SleeperFlow(this);
    sleeper_flow_->SleepOnce(r_);
    return CallFlow(sleeper_flow_, ST(ChildDone));
  }

  StateFlowAction ChildDone() {
    delete sleeper_flow_;
    return Exit();
  }
};

TEST_F(StateFlowTest, FlowWithChildTest) {
  SubFlowCaller f(&done_notifier_);
  bool r = false;
  f.RunFlowAndSubFlow(&r);
  done_notifier_.WaitForNotification();
  EXPECT_TRUE(r);
}
*/

TEST(StaticStateFlowTest, SizeSmall)
{
#if INTPTR_MAX == UINT32_MAX
    EXPECT_EQ(4U, sizeof(QMember));
    // This value is not correct. Needs update.
    EXPECT_EQ(208U, sizeof(StateFlow<Buffer<string>, QList<1>>));
#else
    EXPECT_EQ(8U, sizeof(QMember));
    EXPECT_EQ(208U, sizeof(StateFlow<Buffer<string>, QList<1>>));
#endif
}

struct Increment
{
    void reset(int *p, int c)
    {
        ptr = p;
        len = c;
    }
    int *ptr;
    int len;

    BarrierNotifiable done;
};

class IncrementFlow : public StateFlow<Buffer<Increment>, QList<1>>
{
public:
    IncrementFlow()
        : StateFlow<Buffer<Increment>, QList<1>>(&g_service)
    {
    }

    Action entry()
    {
        return sleep_and_call(&timer_, MSEC_TO_NSEC(15), STATE(do_inc));
    }

    Action do_inc()
    {
        *message()->data()->ptr += message()->data()->len;
        return_buffer();
        return exit();
    }

private:
    StateFlowTimer timer_{this};
};

class DriverFlow : public StateFlowBase
{
public:
    DriverFlow(IncrementFlow *child, Notifiable* n)
        : StateFlowBase(&g_service)
        , member_(5)
        , child_(child)
        , done_(n)
    {
        start_flow(STATE(do_a_call));
    }

    Action do_a_call()
    {
        return invoke_subflow_and_wait(child_, STATE(call_done), &member_, 13);
    }

    Action call_done()
    {
        done_->notify();
        return exit();
    }

    int member_;
    FlowInterface<Buffer<Increment>> *child_;
    Notifiable* done_;
};

TEST(ChildFlowCall, CallOnce) {
    IncrementFlow iflow;
    SyncNotifiable sn;
    BarrierNotifiable bn(&sn);
    DriverFlow df(&iflow, bn.new_child());
    bn.notify();
    sn.wait_for_notification();
    EXPECT_EQ(18, df.member_);
}

TEST(ChildFlowCall, CallMany) {
    IncrementFlow iflow;
    SyncNotifiable sn;
    BarrierNotifiable bn(&sn);
    std::list<DriverFlow> df;
    for (int i = 0; i < 33; ++i) {
        df.emplace_back(&iflow, bn.new_child());
    }
    bn.notify();
    sn.wait_for_notification();
    for (auto& e : df) {
        EXPECT_EQ(18, e.member_);
    }
}
