#include "utils/async_if_test_helper.hxx"
#include "freertos/bootloader_hal.h"

#include "Bootloader.hxx"
#include <string>
#include <functional>

using ::testing::Return;
using ::testing::InvokeWithoutArgs;

extern "C" {
/** This calls into the bootloader main. */
extern void bootloader_entry();

extern Atomic g_bootloader_lock;
}

namespace nmranet
{
namespace
{

class MockBootloaderHAL
{
public:
    MOCK_METHOD0(bootloader_hw_set_to_safe, void());
    MOCK_METHOD0(bootloader_hw_init, void());
    MOCK_METHOD0(request_bootloader, bool());
    MOCK_METHOD0(application_entry, void());
    MOCK_METHOD0(bootloader_reboot, void());
    MOCK_METHOD0(nmranet_nodeid, uint64_t());
    MOCK_METHOD0(nmranet_alias, uint16_t());
    // Argument is the offset from the beginning of virtual_flash.
    MOCK_METHOD1(erase_flash_page, void(uint32_t offset));
    MOCK_METHOD3(write_flash,
                 void(uint32_t offset, string payload, uint32_t size_bytes));
};

static MockBootloaderHAL *g_mock_bootloader_hal = nullptr;

#define FLASH_SIZE 13 * 1024
static uint8_t virtual_flash[FLASH_SIZE];
#define APP_HEADER_OFFSET 131 * 4

/** Proxy class for sending canbus traffic to the Bootloader HAL. */
class BootloaderPort : public CanHubPort
{
public:
    BootloaderPort() : CanHubPort(&g_service)
    {
        is_waiting_ = false;
    }

    bool is_waiting()
    {
        return is_waiting_;
    }

    virtual Action entry()
    {
        AtomicHolder h(this);
        is_waiting_ = true;
        return wait_and_call(STATE(sent));
    }

    Action sent()
    {
        return release_and_exit();
    }

    bool read_can_frame(struct can_frame *frame)
    {
        {
            AtomicHolder h(this);
            if (is_waiting_)
            {
                *frame = *message()->data();
                is_waiting_ = false;
            }
            else
            {
                return false;
            }
        }
        notify();
        return true;
    }

private:
    /** True if an incoming message is ready for dispatching and the current
     * flow is waiting for a notify. */
    bool is_waiting_ = false;
};

BootloaderPort *g_bootloader_port = nullptr;

extern "C" {

extern unsigned g_bootloader_busy;

void bootloader_hw_set_to_safe()
{
    g_mock_bootloader_hal->bootloader_hw_set_to_safe();
}
void bootloader_hw_init()
{
    g_mock_bootloader_hal->bootloader_hw_init();
}

bool request_bootloader()
{
    return g_mock_bootloader_hal->request_bootloader();
}

void application_entry()
{
    return g_mock_bootloader_hal->application_entry();
}

void bootloader_reboot()
{
    return g_mock_bootloader_hal->bootloader_reboot();
}

bool read_can_frame(struct can_frame *frame)
{
    return g_bootloader_port->read_can_frame(frame);
}

bool try_send_can_frame(const struct can_frame &frame)
{
    auto *b = can_hub0.alloc();
    *b->data()->mutable_frame() = frame;
    b->data()->skipMember_ = g_bootloader_port;
    can_hub0.send(b);
    return true;
}

void get_flash_boundaries(const void **flash_min, const void **flash_max,
                          const struct app_header **app_header)
{
    *flash_min = virtual_flash;
    *flash_max = virtual_flash + FLASH_SIZE;
    *app_header = reinterpret_cast<const struct app_header *>(
        &virtual_flash[APP_HEADER_OFFSET]);
}

/** Rounds a flash address into a flash page.
 *
 * @param address is the address for which the page information is queried.
 * @param page_start will be set to the first byte of that page.
 * @param page_length_bytes is set to the number of bytes in that flash page.
 *
 * In other words, *page_start <= address < (*page_start + *page_length_bytes).
 */
void get_flash_page_info(const void *address, const void **page_start,
                         uint32_t *page_length_bytes)
{
    // Simulates a flat 1KB page structure.
    uint32_t value = reinterpret_cast<uint32_t>(address);
    value -= reinterpret_cast<uint32_t>(&virtual_flash[0]);
    value &= ~1023;
    *page_start = &virtual_flash[value];
    *page_length_bytes = 1024;
}

/** Erases the flash page at a specific address. Blocks the caller until the
 * flash erase is successful. (Microcontrollers often cannot execute code while
 * the flash is being written or erased, so a polling mechanism would not help
 * here too much.)
 *
 * @param address is the start address of a valid page, as returned by
 * get_flash_page_info.
 */
void erase_flash_page(const void *address)
{
    uint8_t *dest = (uint8_t *)address;
    g_mock_bootloader_hal->erase_flash_page(dest - virtual_flash);
    // Actually clears the page in the virtual flash.
    const void *page_start;
    uint32_t page_length;
    get_flash_page_info(address, &page_start, &page_length);
    ASSERT_EQ(address, page_start);

    ASSERT_LE(&virtual_flash[0], dest);
    ASSERT_GE(&virtual_flash[FLASH_SIZE], &dest[page_length]);
    memset(dest, 0xff, page_length);
}

void write_flash(const void *address, const void *data, uint32_t size_bytes)
{
    uint8_t *dest = (uint8_t *)address;
    string payload(static_cast<const char *>(data), size_bytes);
    g_mock_bootloader_hal->write_flash(dest - virtual_flash, payload,
                                       size_bytes);
    ASSERT_LE(&virtual_flash[0], dest);
    ASSERT_GE(&virtual_flash[FLASH_SIZE], &dest[size_bytes]);
    memcpy(dest, data, size_bytes);
}

uint16_t nmranet_alias()
{
    return g_mock_bootloader_hal->nmranet_alias();
}

extern uint64_t nmranet_nodeid()
{
    return g_mock_bootloader_hal->nmranet_nodeid();
}

void checksum_data(const void *data, uint32_t size, uint32_t *checksum)
{
    string data_copy(reinterpret_cast<const char *>(data), size);
    hash<string> obj;
    checksum[0] = obj("sd1" + data_copy);
    checksum[1] = obj("xar" + data_copy);
    checksum[2] = obj("o33" + data_copy);
    checksum[3] = 0;
    if (0)
    {
        fprintf(stderr, "Checksum %p-> %5d : %08x%08x%08x%08x\n", data, size,
                checksum[0], checksum[1], checksum[2], checksum[3]);
    }
}

/** This calls into the bootloader main. */
extern void bootloader_entry();
extern bool check_application_checksum();
}

class BootloaderTestBase
{
protected:
    BootloaderTestBase()
    {
        g_mock_bootloader_hal = &mock_;
        memset(virtual_flash, 0, FLASH_SIZE);
        can_hub0.register_port(&can_port_);
        g_bootloader_port = &can_port_;
    }

    ~BootloaderTestBase()
    {
        wait_for_main_executor();
        g_bootloader_port = nullptr;
        can_hub0.unregister_port(&can_port_);
        g_mock_bootloader_hal = nullptr;
        memset(virtual_flash, 0, FLASH_SIZE);
    }

    void create_correct_checksum(uint32_t total_size)
    {
        ASSERT_GE(total_size, APP_HEADER_OFFSET + sizeof(struct app_header));
        ASSERT_GE(FLASH_SIZE, total_size);
        struct app_header *hdr = reinterpret_cast<struct app_header *>(
            &virtual_flash[APP_HEADER_OFFSET]);
        checksum_data(virtual_flash, APP_HEADER_OFFSET, hdr->checksum_pre);
        checksum_data(
            virtual_flash + APP_HEADER_OFFSET + sizeof(struct app_header),
            total_size - APP_HEADER_OFFSET - sizeof(struct app_header),
            hdr->checksum_post);
        hdr->app_size = total_size;
    }

    void expect_boot(bool request_bootloader)
    {
        ::testing::InSequence seq;
        EXPECT_CALL(mock_, bootloader_hw_set_to_safe());
        EXPECT_CALL(mock_, bootloader_hw_init());
        EXPECT_CALL(mock_, request_bootloader())
            .WillOnce(Return(request_bootloader));
    }

    void fill_flash_random(uint32_t size)
    {
        for (uint32_t i = 0; i < size; ++i)
        {
            int rval = rand();
            rval ^= rval >> 16;
            rval ^= rval >> 8;
            virtual_flash[i] = rval & 0xff;
        }
    }

    ::testing::StrictMock<MockBootloaderHAL> mock_;
    BootloaderPort can_port_;
};

class BootloaderTest : public AsyncCanTest, protected BootloaderTestBase
{
protected:
    BootloaderTest()
    {
        EXPECT_CALL(mock_, nmranet_alias()).WillRepeatedly(Return(0x428));
        EXPECT_CALL(mock_, nmranet_nodeid())
            .WillRepeatedly(Return(0x05010101146CULL));
    }

    ~BootloaderTest()
    {
        // wait_for_main_executor();
        if (running_)
        {
            wait_for_bootloader_exit();
        }
        usleep(100);
        wait_for_main_executor();
    }

    void wait()
    {
        while (can_port_.is_waiting() || !g_executor.empty() ||
               g_bootloader_busy)
        {
            usleep(100);
            AtomicHolder h(&g_bootloader_lock);
        }
    }

    void run_bootloader()
    {
        running_ = true;
        g_bootloader_busy = 1;
        os_thread_create(&bootloader_thread_, "bootloader", 0, 0,
                         &BootloaderTest::bootloader_thread, this);
    }

    void sync_run_bootloader()
    {
        run_bootloader();
        wait_for_bootloader_exit();
    }

    void wait_for_bootloader_exit()
    {
        wait();
        bootloader_exited_.wait_for_notification();
    }

    void exit_bootloader()
    {
        EXPECT_CALL(mock_, bootloader_reboot());
        expect_packet(":X19A28428N0111;");
        send_packet(":X1A428111N20A9;");
    }

    static void *bootloader_thread(void *arg)
    {
        BootloaderTest *t = static_cast<BootloaderTest *>(arg);
        bootloader_entry();
        t->running_ = false;
        t->bootloader_exited_.notify();
        return nullptr;
    }

    void proper_startup()
    {
        expect_boot(true);
        EXPECT_CALL(mock_, application_entry()).Times(0);
        expect_packet(":X19100428N05010101146C;");
        run_bootloader();
        wait();
        Mock::VerifyAndClear(&canBus_);
    }

    /** Sends a memory config write stream request fo rthe given offset, and
     * puts in expectations on responses.
     *
     * @param offset is an 8-character string with the hex address in
     * big-endian.*/
    void initiate_stream_write(string offset)
    {
        // expect datagram ok
        expect_packet(":X19A28428N0321;");
        // and expect response datagram
        expect_packet(StringPrintf(":X1A321428N2030%sF0;", offset.c_str()))
            .WillOnce(InvokeWithoutArgs([this]
        { send_packet(":X19A28321N0428;"); }));
        send_packet(StringPrintf(":X1A428321N2020%sF01A;", offset.c_str()));
        wait();
        Mock::VerifyAndClear(&canBus_);
    }

    /** Sends a stream setup request and expects correct response. */
    void setup_stream_request()
    {
        // Sends stream setup request.
        expect_packet(":X19868428N0321008080001A5A;");
        send_packet(":X19CC8321N0428008000001A;");
        wait();
        Mock::VerifyAndClear(&canBus_);
    }

    os_thread_t bootloader_thread_ = 0;
    bool running_ = false;
    SyncNotifiable bootloader_exited_;
};

TEST_F(BootloaderTest, CallsHardwareSetupAndNoEntry)
{
    expect_any_packet();
    {
        ::testing::InSequence seq;
        EXPECT_CALL(mock_, bootloader_hw_set_to_safe());
        EXPECT_CALL(mock_, bootloader_hw_init());
        EXPECT_CALL(mock_, request_bootloader()).WillOnce(Return(false));
    }
    // The checksum should fail, so no entry to the application!
    EXPECT_CALL(mock_, application_entry()).Times(0);
    EXPECT_FALSE(check_application_checksum());
    run_bootloader();
    exit_bootloader();
}

TEST_F(BootloaderTest, StartAppIfChecksumOk)
{
    create_correct_checksum(3756);
    EXPECT_TRUE(check_application_checksum());
    expect_boot(false);
    EXPECT_CALL(mock_, application_entry()).Times(1);
    bootloader_entry();
}

TEST_F(BootloaderTest, NoStartAppIfButtonPressed)
{
    expect_any_packet();
    fill_flash_random(3756);
    create_correct_checksum(3756);
    EXPECT_TRUE(check_application_checksum());
    expect_boot(true);
    EXPECT_CALL(mock_, application_entry()).Times(0);
    run_bootloader();
    exit_bootloader();
}

TEST_F(BootloaderTest, NoStartAppIfChecksumTampered)
{
    expect_any_packet();
    fill_flash_random(3756);
    create_correct_checksum(3756);
    EXPECT_TRUE(check_application_checksum());
    expect_boot(false);
    virtual_flash[843] = 0xff;
    EXPECT_FALSE(check_application_checksum());
    EXPECT_CALL(mock_, application_entry()).Times(0);
    run_bootloader();
    exit_bootloader();
}

TEST_F(BootloaderTest, WelcomeMessageArrives)
{
    proper_startup();
    exit_bootloader();
}

TEST_F(BootloaderTest, StartWriteAtOffsetZero)
{
    print_all_packets();
    proper_startup();

    initiate_stream_write("00000000");
    setup_stream_request();

    exit_bootloader();
}

TEST_F(BootloaderTest, RejectStreamOutOfTheBlue)
{
    proper_startup();

    expect_packet(":X19868428N0321000042201A5A;");
    send_packet(":X19CC8321N0428008000001A;");
    wait();
    Mock::VerifyAndClear(&canBus_);

    exit_bootloader();
}

TEST_F(BootloaderTest, RejectStreamWithWrongId)
{
    proper_startup();

    initiate_stream_write("00000000");

    // Sends stream setup request with wrong id (1A vs 55).
    expect_packet(":X19868428N032100004220555A;");
    send_packet(":X19CC8321N04280080000055;");
    wait();
    Mock::VerifyAndClear(&canBus_);

    exit_bootloader();
}

} // namespace
} // namespace nmranet
