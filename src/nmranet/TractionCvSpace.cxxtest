#include "utils/async_traction_test_helper.hxx"
#include "nmranet/TractionTestTrain.hxx"
#include "nmranet/TractionCvSpace.hxx"
#include "nmranet/MemoryConfig.hxx"
#include "nmranet/DatagramCan.hxx"
#include "dcc/PacketFlowInterface.hxx"
#include "dcc/RailcomHub.hxx"

namespace nmranet
{

extern Pool *const g_incoming_datagram_allocator = mainBufferPool;

class MockTrackIf : public dcc::PacketFlowInterface
{
public:
    MOCK_METHOD2(packet,
                 void(const vector<uint8_t> &payload, size_t feedback_key));
    void send(Buffer<dcc::Packet> *b, unsigned prio) OVERRIDE
    {
        vector<uint8_t> payload;
        payload.assign(b->data()->payload, b->data()->payload + b->data()->dlc);
        this->packet(payload, b->data()->feedback_key);
    }
};

class TractionCvTestBase : public TractionTest
{
protected:
    TractionCvTestBase()
    {
        ifCan_->local_aliases()->add(0x0601000000AFULL, 0x272U);
        expect_packet(":X19100272N0601000000AF;");
    }

    ~TractionCvTestBase()
    {
        wait();
    }
};

class TractionCvTest : public TractionCvTestBase
{
protected:
    enum
    {
        TRAIN_NODE_ALIAS = 0x272,
        TRAIN_NODE_ID = 0x0601000000AF
    };

    TractionCvTest()
    {
    }

    ~TractionCvTest()
    {
        wait();
    }

    size_t expected_feedback_key()
    {
        return reinterpret_cast<size_t>(&cv_space_);
    }

    void send_railcom_response(size_t feedback_key, const vector<uint8_t>& ch2_data) {
        auto* b = railcom_hub_.alloc();
        b->data()->feedbackKey = feedback_key;
        b->data()->ch2Size = ch2_data.size();
        memcpy(b->data()->ch2Data, &ch2_data[0], ch2_data.size());
        railcom_hub_.send(b);
    }

    LoggingTrain train_impl_{175};
    TrainNode train_node_{&trainService_, &train_impl_};
    CanDatagramService datagram_support_{ifCan_.get(), 10, 2};
    MemoryConfigHandler memory_config_handler_{&datagram_support_, nullptr, 3};
    dcc::RailcomHubFlow railcom_hub_{&g_service};
    StrictMock<MockTrackIf> track_if_;
    TractionCvSpace cv_space_{&memory_config_handler_, &track_if_,
                              &railcom_hub_,           0xEF};
};

TEST_F(TractionCvTest, CreateDestroy)
{
}

TEST_F(TractionCvTest, NonTractionNodeGetsRejected)
{
    send_packet_and_expect_response(":X1A22A883N204000000037EF01;",
                                    ":X19A4822AN08831081;");
}

TEST_F(TractionCvTest, SingleCvRead)
{
    print_all_packets();
    expect_packet(":X19A28272N088380;");
    EXPECT_CALL(track_if_, packet(_, expected_feedback_key()))
        .Times(1);
    send_packet(":X1A272883N204000000037EF01;");
    wait();
    expect_packet(":X1A883272N205000000037EFC5;");
    send_railcom_response(expected_feedback_key(), {0b10100101, 0b10100110});
    wait();
    send_packet(":X19A28883N027200;");
    wait();
}

TEST_F(TractionCvTest, SingleCvBusyRetry)
{
    print_all_packets();
    expect_packet(":X19A28272N088380;");
    EXPECT_CALL(track_if_, packet(_, expected_feedback_key()));
    send_packet(":X1A272883N204000000037EF01;");
    wait();
    EXPECT_CALL(track_if_, packet(_, expected_feedback_key()));
    send_railcom_response(expected_feedback_key(), {0b11100001});
    wait();
    expect_packet(":X1A883272N205000000037EFC5;");
    send_railcom_response(expected_feedback_key(), {0b10100101, 0b10100110});
    wait();
    send_packet(":X19A28883N027200;");
    wait();
}

} // namespace nmranet
