#include "utils/async_if_test_helper.hxx"
#include "freertos/bootloader_hal.h"

#include "Bootloader.hxx"
#include <string>
#include <functional>

using ::testing::Return;

extern "C" {
/** This calls into the bootloader main. */
extern void bootloader_entry();
}

namespace nmranet
{
namespace
{

class MockBootloaderHAL
{
public:
    MOCK_METHOD0(bootloader_hw_set_to_safe, void());
    MOCK_METHOD0(bootloader_hw_init, void());
    MOCK_METHOD0(request_bootloader, bool());
    MOCK_METHOD0(application_entry, void());
    MOCK_METHOD0(bootloader_reboot, void());
    MOCK_METHOD0(nmranet_nodeid, uint64_t());
    MOCK_METHOD0(nmranet_alias, uint16_t());
};

static MockBootloaderHAL *g_mock_bootloader_hal = nullptr;

#define FLASH_SIZE 13 * 1024
static uint8_t virtual_flash[FLASH_SIZE];
#define APP_HEADER_OFFSET 131 * 4

/** Proxy class for sending canbus traffic to the Bootloader HAL. */
class BootloaderPort : public CanHubPort
{
public:
    BootloaderPort() : CanHubPort(&g_service)
    {
        is_waiting_ = false;
    }

    virtual Action entry()
    {
        AtomicHolder h(this);
        is_waiting_ = true;
        return wait_and_call(STATE(sent));
    }

    Action sent()
    {
        return release_and_exit();
    }

    bool read_can_frame(struct can_frame *frame)
    {
        {
            AtomicHolder h(this);
            if (is_waiting_)
            {
                *frame = *message()->data();
                is_waiting_ = false;
            }
            else
            {
                return false;
            }
        }
        notify();
        return true;
    }

private:
    /** True if an incoming message is ready for dispatching and the current
     * flow is waiting for a notify. */
    bool is_waiting_ = false;
};

BootloaderPort *g_bootloader_port = nullptr;

extern "C" {
void bootloader_hw_set_to_safe()
{
    g_mock_bootloader_hal->bootloader_hw_set_to_safe();
}
void bootloader_hw_init()
{
    g_mock_bootloader_hal->bootloader_hw_init();
}

bool request_bootloader()
{
    return g_mock_bootloader_hal->request_bootloader();
}

void application_entry()
{
    return g_mock_bootloader_hal->application_entry();
}

void bootloader_reboot()
{
    return g_mock_bootloader_hal->bootloader_reboot();
}

bool read_can_frame(struct can_frame *frame)
{
    return g_bootloader_port->read_can_frame(frame);
}

bool try_send_can_frame(const struct can_frame &frame)
{
    auto *b = can_hub0.alloc();
    *b->data()->mutable_frame() = frame;
    b->data()->skipMember_ = g_bootloader_port;
    can_hub0.send(b);
    return true;
}

void get_flash_boundaries(const void **flash_min, const void **flash_max,
                          const struct app_header **app_header)
{
    *flash_min = virtual_flash;
    *flash_max = virtual_flash + FLASH_SIZE;
    *app_header = reinterpret_cast<const struct app_header *>(
        &virtual_flash[APP_HEADER_OFFSET]);
}

/** Rounds a flash address into a flash page.
 *
 * @param address is the address for which the page information is queried.
 * @param page_start will be set to the first byte of that page.
 * @param page_length_bytes is set to the number of bytes in that flash page.
 *
 * In other words, *page_start <= address < (*page_start + *page_length_bytes).
 */
extern void get_flash_page_info(const void *address, const void **page_start,
                                uint32_t *page_length_bytes);

/** Erases the flash page at a specific address. Blocks the caller until the
 * flash erase is successful. (Microcontrollers often cannot execute code while
 * the flash is being written or erased, so a polling mechanism would not help
 * here too much.)
 *
 * @param address is the start address of a valid page, as returned by
 * get_flash_page_info.
 *
 * @returns zero if the erase is successful, an nmranet error code otherwise.
 */
extern uint16_t erase_flash_page(const void *address);

/** Writes data to the flash.
 *
 * @param address is the location to write data to. Aligned to 4 bytes.
 * @param data is the buffer to write data from.
 * @param size_bytes is the total number of bytes to write. Has to be a
 * multiple of 4.
 */
extern void write_flash(const void *address, const void *data,
                        uint32_t size_bytes);

uint16_t nmranet_alias()
{
    return g_mock_bootloader_hal->nmranet_alias();
}

extern uint64_t nmranet_nodeid()
{
    return g_mock_bootloader_hal->nmranet_nodeid();
}

void checksum_data(const void *data, uint32_t size, uint32_t *checksum)
{
    string data_copy(reinterpret_cast<const char *>(data), size);
    hash<string> obj;
    checksum[0] = obj("sd1" + data_copy);
    checksum[1] = obj("xar" + data_copy);
    checksum[2] = obj("o33" + data_copy);
    checksum[3] = 0;
    if (0)
    {
        fprintf(stderr, "Checksum %p-> %5d : %08x%08x%08x%08x\n", data, size,
                checksum[0], checksum[1], checksum[2], checksum[3]);
    }
}

/** This calls into the bootloader main. */
extern void bootloader_entry();
extern bool check_application_checksum();
}

class BootloaderTestBase
{
protected:
    BootloaderTestBase()
    {
        g_mock_bootloader_hal = &mock_;
        memset(virtual_flash, 0, FLASH_SIZE);
        can_hub0.register_port(&can_port_);
        g_bootloader_port = &can_port_;
    }

    ~BootloaderTestBase()
    {
        wait_for_main_executor();
        g_bootloader_port = nullptr;
        can_hub0.unregister_port(&can_port_);
        g_mock_bootloader_hal = nullptr;
        memset(virtual_flash, 0, FLASH_SIZE);
    }

    void create_correct_checksum(uint32_t total_size)
    {
        ASSERT_GE(total_size, APP_HEADER_OFFSET + sizeof(struct app_header));
        ASSERT_GE(FLASH_SIZE, total_size);
        struct app_header *hdr = reinterpret_cast<struct app_header *>(
            &virtual_flash[APP_HEADER_OFFSET]);
        checksum_data(virtual_flash, APP_HEADER_OFFSET, hdr->checksum_pre);
        checksum_data(
            virtual_flash + APP_HEADER_OFFSET + sizeof(struct app_header),
            total_size - APP_HEADER_OFFSET - sizeof(struct app_header),
            hdr->checksum_post);
        hdr->app_size = total_size;
    }

    void expect_boot(bool request_bootloader)
    {
        ::testing::InSequence seq;
        EXPECT_CALL(mock_, bootloader_hw_set_to_safe());
        EXPECT_CALL(mock_, bootloader_hw_init());
        EXPECT_CALL(mock_, request_bootloader())
            .WillOnce(Return(request_bootloader));
    }

    void fill_flash_random(uint32_t size)
    {
        for (uint32_t i = 0; i < size; ++i)
        {
            int rval = rand();
            rval ^= rval >> 16;
            rval ^= rval >> 8;
            virtual_flash[i] = rval & 0xff;
        }
    }

    ::testing::StrictMock<MockBootloaderHAL> mock_;
    BootloaderPort can_port_;
};

class BootloaderTest : public AsyncCanTest, protected BootloaderTestBase
{
protected:
    BootloaderTest()
    {
        EXPECT_CALL(mock_, nmranet_alias()).WillRepeatedly(Return(0x428));
        EXPECT_CALL(mock_, nmranet_nodeid())
            .WillRepeatedly(Return(0x05010101146CULL));
    }

    ~BootloaderTest()
    {
        // wait_for_main_executor();
        if (running_)
        {
            wait_for_bootloader();
        }
        usleep(100);
        wait_for_main_executor();
    }

    void run_bootloader()
    {
        running_ = true;
        os_thread_create(&bootloader_thread_, "bootloader", 0, 0,
                         &BootloaderTest::bootloader_thread, this);
    }

    void sync_run_bootloader()
    {
        run_bootloader();
        wait_for_bootloader();
    }

    void wait_for_bootloader()
    {
        wait();
        bootloader_exited_.wait_for_notification();
    }

    void exit_bootloader()
    {
        EXPECT_CALL(mock_, bootloader_reboot());
        expect_packet(":X19A28428N0321;");
        send_packet(":X1A428321N20A9;");
    }

    static void *bootloader_thread(void *arg)
    {
        BootloaderTest *t = static_cast<BootloaderTest *>(arg);
        bootloader_entry();
        t->running_ = false;
        t->bootloader_exited_.notify();
        return nullptr;
    }

    os_thread_t bootloader_thread_ = 0;
    bool running_ = false;
    SyncNotifiable bootloader_exited_;
};

TEST_F(BootloaderTest, CallsHardwareSetupAndNoEntry)
{
    expect_any_packet();
    {
        ::testing::InSequence seq;
        EXPECT_CALL(mock_, bootloader_hw_set_to_safe());
        EXPECT_CALL(mock_, bootloader_hw_init());
        EXPECT_CALL(mock_, request_bootloader()).WillOnce(Return(false));
    }
    // The checksum should fail, so no entry to the application!
    EXPECT_CALL(mock_, application_entry()).Times(0);
    EXPECT_FALSE(check_application_checksum());
    run_bootloader();
    exit_bootloader();
}

TEST_F(BootloaderTest, StartAppIfChecksumOk)
{
    create_correct_checksum(3756);
    EXPECT_TRUE(check_application_checksum());
    expect_boot(false);
    EXPECT_CALL(mock_, application_entry()).Times(1);
    bootloader_entry();
}

TEST_F(BootloaderTest, NoStartAppIfButtonPressed)
{
    expect_any_packet();
    fill_flash_random(3756);
    create_correct_checksum(3756);
    EXPECT_TRUE(check_application_checksum());
    expect_boot(true);
    EXPECT_CALL(mock_, application_entry()).Times(0);
    run_bootloader();
    exit_bootloader();
}

TEST_F(BootloaderTest, NoStartAppIfChecksumTampered)
{
    expect_any_packet();
    fill_flash_random(3756);
    create_correct_checksum(3756);
    EXPECT_TRUE(check_application_checksum());
    expect_boot(false);
    virtual_flash[843] = 0xff;
    EXPECT_FALSE(check_application_checksum());
    EXPECT_CALL(mock_, application_entry()).Times(0);
    run_bootloader();
    exit_bootloader();
}

TEST_F(BootloaderTest, WelcomeMessageArrives)
{
    print_all_packets();
    expect_boot(true);
    EXPECT_CALL(mock_, application_entry()).Times(0);
    expect_packet(":X19100428N05010101146C;");
    run_bootloader();
    exit_bootloader();
}

} // namespace
} // namespace nmranet
