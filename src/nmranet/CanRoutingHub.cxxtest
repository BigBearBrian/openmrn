#include "utils/async_if_test_helper.hxx"

#include "nmranet/CanRoutingHub.hxx"

namespace nmranet {
namespace {

class CanRoutingHubTest : public ::testing::Test {
protected:
    typedef StrictMock<MockSend> PortType;
    void test_packet(const string& packet, PortType* source, std::initializer_list<PortType*> destinations) {
        for (PortType* dst : destinations) {
            EXPECT_CALL(*dst, mwrite(StrCaseEq(packet)));
        }
        auto* b = hub_.alloc();
        b->data()->skipMember_ = source;
        b->data()->assign(packet);
        hub_.send(b);
        wait();
    }

    ~CanRoutingHubTest() {
        wait();
    }

    void wait() {
        wait_for_main_executor();
        for (PortType* p : all_ports()) {
            Mock::VerifyAndClear(p);
        }
    }

    const std::vector<PortType*>& all_ports() {
        return allPorts_;
    }

    void register_all_ports() {
        for (PortType* p : allPorts_) {
            hub_.register_port(p);
        }
    }

    GcCanRoutingHub hub_{&g_service};
    PortType p1_, p2_, p3_, p4_;
    std::vector<PortType*> allPorts_{&p1_, &p2_, &p3_, &p4_};
};


TEST_F(CanRoutingHubTest, Construct) {}

TEST_F(CanRoutingHubTest, SimpleStdPacket) {
    register_all_ports();

    test_packet(":S000N;", &p1_, {&p2_, &p3_, &p4_});
}

TEST_F(CanRoutingHubTest, Unregister) {
    register_all_ports();

    test_packet(":S000N;", &p1_, {&p2_, &p3_, &p4_});

    hub_.unregister_port(&p3_);

    test_packet(":S000N;", &p1_, {&p2_, &p4_});
}

TEST_F(CanRoutingHubTest, Addressed) {
    register_all_ports();

    // This will not add anything to the routing table
    test_packet(":S111N;", &p1_, {&p2_, &p3_, &p4_});
    // Addressed packet will be broadcast
    test_packet(":X19828444N0111;", &p4_, {&p1_, &p2_, &p3_});
    // We do add to the routing table
    test_packet(":X19100111N050101011800;", &p1_, {&p2_, &p3_, &p4_});
    // Addressed packet will be unicast
    test_packet(":X19828444N0111;", &p4_, {&p1_});
    // Response too.
    test_packet(":X19668111N0444000000000000;", &p1_, {&p4_});
    
    // a global packet will be still broadcast
    test_packet(":X19490444N;", &p4_, {&p1_, &p2_, &p3_});
}

TEST_F(CanRoutingHubTest, AddressTransition) {
    register_all_ports();

    // We do add to the routing table
    test_packet(":X19100111N050101011800;", &p1_, {&p2_, &p3_, &p4_});
    // Addressed packet will be unicast
    test_packet(":X19828444N0111;", &p4_, {&p1_});
    // Different source
    test_packet(":X19100111N050101011800;", &p2_, {&p1_, &p3_, &p4_});
    // Addressed packet will be unicast to new target
    test_packet(":X19828444N0111;", &p4_, {&p2_});
}

TEST_F(CanRoutingHubTest, NoAddressTransitionOnCID) {
    register_all_ports();

    // We do add to the routing table
    test_packet(":X10701111N050101011800;", &p1_, {&p2_, &p3_, &p4_});
    // Addressed packet will be unicast
    test_packet(":X19828444N0111;", &p4_, {&p1_});
    // Different source but CID frame
    test_packet(":X16999111N;", &p2_, {&p1_, &p3_, &p4_});
    // Addressed packet will be unicast to oldrget
    test_packet(":X19828444N0111;", &p4_, {&p1_});
}

} // namespace
} // namespace nmranet
