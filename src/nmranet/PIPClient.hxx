/** \copyright
 * Copyright (c) 2015, Balazs Racz
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  - Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  - Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * \file PIPClient.hxx
 *
 * A client library for talking to an arbitrary nmranet Node and ask it for the
 * supported protocol data.
 *
 * @author Balazs Racz
 * @date 31 Oct 2015
 */

#include "executor/StateFlow.hxx"
#include "nmranet/Defs.hxx"
#include "nmranet/If.hxx"
#include "os/os.h"

namespace nmranet
{

class PIPClient : public StateFlowBase
{
public:
    PIPClient(If *interface)
        : StateFlowBase(interface)
    {
    }

    /** Sends a PIP request to the specified node.
     *
     * The current
     *
     * @param dst is the target node to query
     * @param src is the source node from which to send query
     * @param done will be notified if the request succeeds or fails or
     * timeouts)
     */
    void request(NodeHandle dst, Node* src, Notifiable *done)
    {
        src_ = src;
        dst_ = dst;
        done_ = done;
        errorCode_ = OPERATION_PENDING;
        pipResponse_ = 0;
        start_flow(STATE(request_buffer));
    }

    /** Returns the error code of the last request, or one of the internal
     * error codes from \ref ResultCodes */
    uint32_t error_code() {
        return errorCode_;
    }

    /** Returns the response of the last request out, or unspecified if the
     * last request has not succeeded. */
    uint64_t response() {
        return pipResponse_;
    }

    enum ResultCodes {
        // Internal error codes generated by the send flow
        OPERATION_SUCCESS = 0x10000, //< set when the Datagram OK arrives
        OPERATION_PENDING = 0x20000, //< cleared when done is called.
        DST_NOT_FOUND = 0x40000,     //< on CAN. Permanent error code.
        TIMEOUT = 0x80000,           //< Timeout waiting for ack/nack.

        IDLE = 0xFFFF0000, //< The current flow is not in use.

    };

    static const long long TIMEOUT_NSEC = SEC_TO_NSEC(4);

private:
    Action request_buffer()
    {
        return allocate_and_call(
            interface()->addressed_message_write_flow(), STATE(write_request));
    }

    Action write_request() {
        auto* b = get_allocation_result(interface()->addressed_message_write_flow());
        b->data()->reset(Defs::MTI_PROTOCOL_SUPPORT_INQUIRY, src_->node_id(), dst_, EMPTY_PAYLOAD);
        interface()->addressed_message_write_flow()->send(b);

        return sleep_and_call(&timer_, TIMEOUT_NSEC, STATE(response_came));
    }

    // Callback from the response handler.
    void handle_response(Buffer<NMRAnetMessage> *message) {
        if (message->dstNode != src_ ||
            interface()->matching_node(dst_, message->src_)) {
            // Not from the right place.
            return message->unref();
        }
        if (message->mti ==
    }

    class PIPResponseHandler : public MessageHandler
    {
    public:
        PIPResponseHandler(PIPClient *parent)
            : parent_(parent)
        {
        }

        void send(Buffer<NMRAnetMessage> *message, unsigned priority) OVERRIDE
        {
            parent_->handle_response(message);
        }

    private:
        PIPClient *parent_;
    };

    If *interface()
    {
        return static_cast<If *>(service());
    }

    StateFlowTimer timer_{this};
    Node* src_;
    Notifiable *done_;
    NodeHandle dst_;
    uint64_t pipResponse_{0};
    uint32_t errorCode_{IDLE};
    PIPResponseHandler responseHandler_{this};
};

} // namespace nmranet
